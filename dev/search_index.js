var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LibAwsHTTP","category":"page"},{"location":"#LibAwsHTTP","page":"Home","title":"LibAwsHTTP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LibAwsHTTP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LibAwsHTTP]","category":"page"},{"location":"#LibAwsHTTP.AWS_C_HTTP_PACKAGE_ID","page":"Home","title":"LibAwsHTTP.AWS_C_HTTP_PACKAGE_ID","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsHTTP.AWS_HTTP2_DEFAULT_MAX_CLOSED_STREAMS","page":"Home","title":"LibAwsHTTP.AWS_HTTP2_DEFAULT_MAX_CLOSED_STREAMS","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsHTTP.AWS_HTTP2_PING_DATA_SIZE","page":"Home","title":"LibAwsHTTP.AWS_HTTP2_PING_DATA_SIZE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsHTTP.AWS_HTTP2_SETTINGS_COUNT","page":"Home","title":"LibAwsHTTP.AWS_HTTP2_SETTINGS_COUNT","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsHTTP.AWS_WEBSOCKET_CLOSE_TIMEOUT","page":"Home","title":"LibAwsHTTP.AWS_WEBSOCKET_CLOSE_TIMEOUT","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsHTTP.AWS_WEBSOCKET_MAX_HANDSHAKE_KEY_LENGTH","page":"Home","title":"LibAwsHTTP.AWS_WEBSOCKET_MAX_HANDSHAKE_KEY_LENGTH","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsHTTP.AWS_WEBSOCKET_MAX_PAYLOAD_LENGTH","page":"Home","title":"LibAwsHTTP.AWS_WEBSOCKET_MAX_PAYLOAD_LENGTH","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsHTTP.aws_crt_http_statistics_category","page":"Home","title":"LibAwsHTTP.aws_crt_http_statistics_category","text":"aws_crt_http_statistics_category\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_crt_statistics_http1_channel","page":"Home","title":"LibAwsHTTP.aws_crt_statistics_http1_channel","text":"aws_crt_statistics_http1_channel\n\nA statistics struct for http handlers. Tracks the actual amount of time that incoming and outgoing requests are waiting for their IO to complete.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_crt_statistics_http2_channel","page":"Home","title":"LibAwsHTTP.aws_crt_statistics_http2_channel","text":"aws_crt_statistics_http2_channel\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_future_http_message","page":"Home","title":"LibAwsHTTP.aws_future_http_message","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http1_chunk_extension","page":"Home","title":"LibAwsHTTP.aws_http1_chunk_extension","text":"aws_http1_chunk_extension\n\nHTTP/1.1 chunk extension for chunked encoding. Note that the underlying strings are not owned by the byte cursors.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http1_chunk_options","page":"Home","title":"LibAwsHTTP.aws_http1_chunk_options","text":"aws_http1_chunk_options\n\nEncoding options for an HTTP/1.1 chunked transfer encoding chunk.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http1_connection_options","page":"Home","title":"LibAwsHTTP.aws_http1_connection_options","text":"aws_http1_connection_options\n\nOptions specific to HTTP/1.x connections.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http1_stream_write_chunk_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http1_stream_write_chunk_complete_fn","text":"Invoked when the data of an outgoing HTTP/1.1 chunk is no longer in use. This is always invoked on the HTTP connection's event-loop thread.\n\nArguments\n\nstream: HTTP-stream this chunk was submitted to.\nerror_code: If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent. Any other error_code indicates that the HTTP-stream is in the process of terminating. If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED, the stream's termination has nothing to do with this chunk. Any other non-zero error code indicates a problem with this particular chunk's data.\nuser_data: User data for this chunk.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_connection_options","page":"Home","title":"LibAwsHTTP.aws_http2_connection_options","text":"aws_http2_connection_options\n\nOptions specific to HTTP/2 connections.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_error_code","page":"Home","title":"LibAwsHTTP.aws_http2_error_code","text":"aws_http2_error_code\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_on_change_settings_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http2_on_change_settings_complete_fn","text":"Invoked when the HTTP/2 settings change is complete. If connection setup successfully this will always be invoked whether settings change successfully or unsuccessfully. If error_code is AWS_ERROR_SUCCESS (0), then the peer has acknowledged the settings and the change has been applied. If error_code is non-zero, then a connection error occurred before the settings could be fully acknowledged and applied. This is always invoked on the connection's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_on_goaway_received_fn","page":"Home","title":"LibAwsHTTP.aws_http2_on_goaway_received_fn","text":"Invoked when an HTTP/2 GOAWAY frame is received from peer. Implies that the peer has initiated shutdown, or encountered a serious error. Once a GOAWAY is received, no further streams may be created on this connection.\n\nArguments\n\nhttp2_connection: This HTTP/2 connection.\nlast_stream_id: ID of the last locally-initiated stream that peer will process. Any locally-initiated streams with a higher ID are ignored by peer, and are safe to retry on another connection.\nhttp2_error_code: The HTTP/2 error code (RFC-7540 section 7) sent by peer. enum [awshttp2error_code](@ref) lists official codes.\ndebug_data: The debug data sent by peer. It can be empty. (NOTE: this data is only valid for the lifetime of the callback. Make a deep copy if you wish to keep it longer.)\nuser_data: User-data passed to the callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_on_ping_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http2_on_ping_complete_fn","text":"Invoked when the HTTP/2 PING completes, whether peer has acknowledged it or not. If error_code is AWS_ERROR_SUCCESS (0), then the peer has acknowledged the PING and round_trip_time_ns will be the round trip time in nano seconds for the connection. If error_code is non-zero, then a connection error occurred before the PING get acknowledgment and round_trip_time_ns will be useless in this case.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_on_remote_settings_change_fn","page":"Home","title":"LibAwsHTTP.aws_http2_on_remote_settings_change_fn","text":"Invoked when new HTTP/2 settings from peer have been applied. Settings_array is the array of aws_http2_settings that contains all the settings we just changed in the order we applied (the order settings arrived). Num_settings is the number of elements in that array.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_setting","page":"Home","title":"LibAwsHTTP.aws_http2_setting","text":"aws_http2_setting\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_settings_id","page":"Home","title":"LibAwsHTTP.aws_http2_settings_id","text":"aws_http2_settings_id\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_stream_manager","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_acquire_stream_options","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_acquire_stream_options","text":"aws_http2_stream_manager_acquire_stream_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_on_stream_acquired_fn","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_on_stream_acquired_fn","text":"Always invoked asynchronously when the stream was created, successfully or not. When stream is NULL, error code will be set to indicate what happened. If there is a stream returned, you own the stream completely. Invoked on the same thread as other callback of the stream, which will be the thread of the connection, ideally. If there is no connection made, the callback will be invoked from a sperate thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_options","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_options","text":"aws_http2_stream_manager_options\n\nHTTP/2 stream manager configuration struct.\n\nContains all of the configuration needed to create an http2 connection as well as connection manager under the hood.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_shutdown_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_shutdown_complete_fn","text":"Invoked asynchronously when the stream manager has been shutdown completely. Never invoked when aws_http2_stream_manager_new failed.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_stream_write_data_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http2_stream_write_data_complete_fn","text":"Invoked when the data of an outgoing HTTP2 data frame is no longer in use. This is always invoked on the HTTP connection's event-loop thread.\n\nArguments\n\nstream: HTTP2-stream this write was submitted to.\nerror_code: If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent. Any other error_code indicates that the HTTP-stream is in the process of terminating. If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED, the stream's termination has nothing to do with this write. Any other non-zero error code indicates a problem with this particular write's data.\nuser_data: User data for this write.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http2_stream_write_data_options","page":"Home","title":"LibAwsHTTP.aws_http2_stream_write_data_options","text":"aws_http2_stream_write_data_options\n\nEncoding options for manual H2 data frame writes\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_client_connection_options","page":"Home","title":"LibAwsHTTP.aws_http_client_connection_options","text":"aws_http_client_connection_options\n\nOptions for creating an HTTP client connection. Initialize with AWS_HTTP_CLIENT_CONNECTION_OPTIONS_INIT to set default values.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_connection","page":"Home","title":"LibAwsHTTP.aws_http_connection","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_connection_manager","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_connection_manager_on_connection_setup_fn","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_on_connection_setup_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_connection_manager_options","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_options","text":"aws_http_connection_manager_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_connection_manager_shutdown_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_shutdown_complete_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_connection_monitoring_options","page":"Home","title":"LibAwsHTTP.aws_http_connection_monitoring_options","text":"aws_http_connection_monitoring_options\n\nConfiguration options for connection monitoring\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_errors","page":"Home","title":"LibAwsHTTP.aws_http_errors","text":"aws_http_errors\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_header","page":"Home","title":"LibAwsHTTP.aws_http_header","text":"aws_http_header\n\nA lightweight HTTP header struct. Note that the underlying strings are not owned by the byte cursors.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_header_block","page":"Home","title":"LibAwsHTTP.aws_http_header_block","text":"aws_http_header_block\n\nHeader block type. INFORMATIONAL: Header block for 1xx informational (interim) responses. MAIN: Main header block sent with request or response. TRAILING: Headers sent after the body of a request or response.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_header_compression","page":"Home","title":"LibAwsHTTP.aws_http_header_compression","text":"aws_http_header_compression\n\nControls whether a header's strings may be compressed by encoding the index of strings in a cache, rather than encoding the literal string.\n\nThis setting has no effect on HTTP/1.x connections. On HTTP/2 connections this controls HPACK behavior. See RFC-7541 Section 7.1 for security considerations.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_headers","page":"Home","title":"LibAwsHTTP.aws_http_headers","text":"A transformable block of HTTP headers. Provides a nice API for getting/setting header names and values.\n\nAll strings are copied and stored within this datastructure. The index of a given header may change any time headers are modified. When iterating headers, the following ordering rules apply:\n\nHeaders with the same name will always be in the same order, relative to one another. If \"A: one\" is added before \"A: two\", then \"A: one\" will always precede \"A: two\".\nHeaders with different names could be in any order, relative to one another. If \"A: one\" is seen before \"B: bee\" in one iteration, you might see \"B: bee\" before \"A: one\" on the next.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_log_subject","page":"Home","title":"LibAwsHTTP.aws_http_log_subject","text":"aws_http_log_subject\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_make_request_options","page":"Home","title":"LibAwsHTTP.aws_http_make_request_options","text":"aws_http_make_request_options\n\nOptions for creating a stream which sends a request from the client and receives a response from the server.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_manager_metrics","page":"Home","title":"LibAwsHTTP.aws_http_manager_metrics","text":"aws_http_manager_metrics\n\nMetrics for logging and debugging purpose.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_message","page":"Home","title":"LibAwsHTTP.aws_http_message","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_message_transform_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http_message_transform_complete_fn","text":"Function to invoke when a message transformation completes. This function MUST be invoked or the application will soft-lock. message and complete_ctx must be the same pointers provided to the aws_http_message_transform_fn. error_code should should be AWS_ERROR_SUCCESS if transformation was successful, otherwise pass a different AWS_ERROR_X value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_message_transform_fn","page":"Home","title":"LibAwsHTTP.aws_http_message_transform_fn","text":"A function that may modify a request or response before it is sent. The transformation may be asynchronous or immediate. The user MUST invoke the complete_fn when transformation is complete or the application will soft-lock. When invoking the complete_fn, pass along the message and complete_ctx provided here and an error code. The error code should be AWS_ERROR_SUCCESS if transformation was successful, otherwise pass a different AWS_ERROR_X value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_client_connection_setup_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_client_connection_setup_fn","text":"Invoked when connect completes.\n\nIf unsuccessful, error_code will be set, connection will be NULL, and the on_shutdown callback will never be invoked.\n\nIf successful, error_code will be 0 and connection will be valid. The user is now responsible for the connection and must call aws_http_connection_release() when they are done with it.\n\nThe connection uses one event-loop thread to do all its work. The thread invoking this callback will be the same thread that invokes all future callbacks for this connection and its streams.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_client_connection_shutdown_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_client_connection_shutdown_fn","text":"Invoked when the connection has finished shutting down. Never invoked if on_setup failed. This is always invoked on connection's event-loop thread. Note that the connection is not completely done until on_shutdown has been invoked AND aws_http_connection_release() has been called.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_incoming_body_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_incoming_body_fn","text":"Called repeatedly as body data is received. The data must be copied immediately if you wish to preserve it. This is always invoked on the HTTP connection's event-loop thread.\n\nNote that, if the connection is using manual_window_management then the window size has shrunk by the amount of body data received. If the window size reaches 0 no further data will be received. Increment the window size with aws_http_stream_update_window().\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return aws_raise_error(E) to indicate failure and cancel the stream. The error you raise will be reflected in the error_code passed to the on_complete callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_incoming_header_block_done_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_incoming_header_block_done_fn","text":"Invoked when the incoming header block of this type(informational/main/trailing) has been completely read. This is always invoked on the HTTP connection's event-loop thread.\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return aws_raise_error(E) to indicate failure and cancel the stream. The error you raise will be reflected in the error_code passed to the on_complete callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_incoming_headers_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_incoming_headers_fn","text":"Invoked repeatedly times as headers are received. At this point, aws_http_stream_get_incoming_response_status() can be called for the client. And aws_http_stream_get_incoming_request_method() and aws_http_stream_get_incoming_request_uri() can be called for the server. This is always invoked on the HTTP connection's event-loop thread.\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return aws_raise_error(E) to indicate failure and cancel the stream. The error you raise will be reflected in the error_code passed to the on_complete callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_incoming_request_done_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_incoming_request_done_fn","text":"Invoked when request has been completely read. This is always invoked on the HTTP connection's event-loop thread.\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return aws_raise_error(E) to indicate failure and cancel the stream. The error you raise will be reflected in the error_code passed to the on_complete callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_incoming_request_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_incoming_request_fn","text":"Invoked at the start of an incoming request. To process the request, the user must create a request handler stream and return it to the connection. If NULL is returned, the request will not be processed and the last error will be reported as the reason for failure.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_server_connection_shutdown_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_server_connection_shutdown_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_stream_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_stream_complete_fn","text":"Invoked when a request/response stream is complete, whether successful or unsuccessful This is always invoked on the HTTP connection's event-loop thread. This will not be invoked if the stream is never activated.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_stream_destroy_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_stream_destroy_fn","text":"Invoked when request/response stream destroy completely. This can be invoked within the same thead who release the refcount on http stream. This is invoked even if the stream is never activated.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_on_stream_metrics_fn","page":"Home","title":"LibAwsHTTP.aws_http_on_stream_metrics_fn","text":"Invoked right before request/response stream is complete to report the tracing metrics for aws_http_stream. This may be invoked synchronously when aws_http_stream_release() is called. This is invoked even if the stream is never activated. See aws_http_stream_metrics for details.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_authentication_type","page":"Home","title":"LibAwsHTTP.aws_http_proxy_authentication_type","text":"aws_http_proxy_authentication_type\n\ncompat: Deprecated\nSupported proxy authentication modes. Superceded by proxy strategy.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_config","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_connection_type","page":"Home","title":"LibAwsHTTP.aws_http_proxy_connection_type","text":"aws_http_proxy_connection_type\n\nSupported proxy connection types\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_env_var_type","page":"Home","title":"LibAwsHTTP.aws_http_proxy_env_var_type","text":"aws_http_proxy_env_var_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_connect_on_incoming_headers_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_connect_on_incoming_headers_fn","text":"Tunneling proxy connections only. A callback that lets the negotiator examine the headers in the response to the most recent CONNECT request as they arrive.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_get_challenge_token_sync_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_get_challenge_token_sync_fn","text":"Synchronous (for now) callback function to fetch a token used in modifying CONNECT request. Includes a (byte string) context intended to be used as part of a challenge-response flow.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_get_token_sync_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_get_token_sync_fn","text":"Synchronous (for now) callback function to fetch a token used in modifying CONNECT requests\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_http_request_forward_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_http_request_forward_fn","text":"Proxy negotiation logic must call this function to forward the potentially-mutated request back to the proxy connection logic.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_http_request_transform_async_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_http_request_transform_async_fn","text":"User-supplied transform callback which implements the proxy request flow and ultimately, across all execution pathways, invokes either the terminate function or the forward function appropriately.\n\nFor tunneling proxy connections, this request flow transform only applies to the CONNECT stage of proxy connection establishment.\n\nFor forwarding proxy connections, this request flow transform applies to every single http request that goes out on the connection.\n\nForwarding proxy connections cannot yet support a truly async request transform without major surgery on http stream creation, so for now, we split into an async version (for tunneling proxies) and a separate synchronous version for forwarding proxies. Also forwarding proxies are a kind of legacy dead-end in some sense.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_http_request_transform_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_http_request_transform_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_retry_directive","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_retry_directive","text":"aws_http_proxy_negotiation_retry_directive\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiation_terminate_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiation_terminate_fn","text":"Proxy negotiation logic must call this function to indicate an unsuccessful outcome\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator","text":"aws_http_proxy_negotiator\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator_connect_on_incoming_body_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator_connect_on_incoming_body_fn","text":"Tunneling proxy connections only. A callback that lets the negotiator examine the body of the response to the most recent CONNECT request.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator_connect_status_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator_connect_status_fn","text":"Tunneling proxy connections only. A callback that lets the negotiator examine the status code of the response to the most recent CONNECT request.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator_forwarding_vtable","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator_forwarding_vtable","text":"aws_http_proxy_negotiator_forwarding_vtable\n\nVtable for forwarding-based proxy negotiators\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator_get_retry_directive_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator_get_retry_directive_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator_tunnelling_vtable","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator_tunnelling_vtable","text":"aws_http_proxy_negotiator_tunnelling_vtable\n\nVtable for tunneling-based proxy negotiators\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_options","page":"Home","title":"LibAwsHTTP.aws_http_proxy_options","text":"aws_http_proxy_options\n\nOptions for http proxy server usage\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy","text":"aws_http_proxy_strategy\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_basic_auth_options","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_basic_auth_options","text":"aws_http_proxy_strategy_basic_auth_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_create_negotiator_fn","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_create_negotiator_fn","text":"\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_tunneling_adaptive_options","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_tunneling_adaptive_options","text":"aws_http_proxy_strategy_tunneling_adaptive_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_tunneling_kerberos_options","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_tunneling_kerberos_options","text":"aws_http_proxy_strategy_tunneling_kerberos_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_tunneling_ntlm_options","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_tunneling_ntlm_options","text":"aws_http_proxy_strategy_tunneling_ntlm_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_tunneling_sequence_options","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_tunneling_sequence_options","text":"aws_http_proxy_strategy_tunneling_sequence_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_vtable","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_vtable","text":"aws_http_proxy_strategy_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_request_handler_options","page":"Home","title":"LibAwsHTTP.aws_http_request_handler_options","text":"aws_http_request_handler_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_server","page":"Home","title":"LibAwsHTTP.aws_http_server","text":"A listening socket which accepts incoming HTTP connections, creating a server-side aws_http_connection to handle each one.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_server_connection_options","page":"Home","title":"LibAwsHTTP.aws_http_server_connection_options","text":"aws_http_server_connection_options\n\nOptions for configuring a server-side aws_http_connection. Initialized with AWS_HTTP_SERVER_CONNECTION_OPTIONS_INIT to set default values.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_server_on_destroy_fn","page":"Home","title":"LibAwsHTTP.aws_http_server_on_destroy_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_server_on_incoming_connection_fn","page":"Home","title":"LibAwsHTTP.aws_http_server_on_incoming_connection_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_server_options","page":"Home","title":"LibAwsHTTP.aws_http_server_options","text":"aws_http_server_options\n\nOptions for creating an HTTP server. Initialize with AWS_HTTP_SERVER_OPTIONS_INIT to set default values.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_statistics_observer_fn","page":"Home","title":"LibAwsHTTP.aws_http_statistics_observer_fn","text":"Callback invoked on each statistics sample.\n\nconnection_nonce is unique to each connection for disambiguation of each callback per connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_status_code","page":"Home","title":"LibAwsHTTP.aws_http_status_code","text":"aws_http_status_code\n\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved. SPDX-License-Identifier: Apache-2.0.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_stream","page":"Home","title":"LibAwsHTTP.aws_http_stream","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_stream_metrics","page":"Home","title":"LibAwsHTTP.aws_http_stream_metrics","text":"aws_http_stream_metrics\n\nTracing metrics for aws_http_stream. Data maybe not be available if the data of stream was never sent/received before it completes.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_stream_write_complete_fn","page":"Home","title":"LibAwsHTTP.aws_http_stream_write_complete_fn","text":"Invoked when the data stream of an outgoing HTTP write operation is no longer in use. This is always invoked on the HTTP connection's event-loop thread.\n\nArguments\n\nstream: HTTP-stream this write operation was submitted to.\nerror_code: If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent. Any other error_code indicates that the HTTP-stream is in the process of terminating. If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED, the stream's termination has nothing to do with this write operation. Any other non-zero error code indicates a problem with this particular write operation's data.\nuser_data: User data for this write operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_http_version","page":"Home","title":"LibAwsHTTP.aws_http_version","text":"aws_http_version\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket","page":"Home","title":"LibAwsHTTP.aws_websocket","text":"A websocket connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_client_connection_options","page":"Home","title":"LibAwsHTTP.aws_websocket_client_connection_options","text":"aws_websocket_client_connection_options\n\nOptions for creating a websocket client connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_incoming_frame","page":"Home","title":"LibAwsHTTP.aws_websocket_incoming_frame","text":"aws_websocket_incoming_frame\n\nData about an incoming frame. See RFC-6455 Section 5.2.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_on_connection_setup_data","page":"Home","title":"LibAwsHTTP.aws_websocket_on_connection_setup_data","text":"aws_websocket_on_connection_setup_data\n\nData passed to the websocket on_connection_setup callback.\n\nAn error_code of zero indicates that setup was completely successful. You own the websocket pointer now and must call aws_websocket_release() when you are done with it. You can inspect the response headers, if you're interested.\n\nA non-zero error_code indicates that setup failed. The websocket pointer will be NULL. If the server sent a response, you can inspect its status-code, headers, and body, but this data will NULL if setup failed before a full response could be received. If you wish to persist data from the response make a deep copy. The response data becomes invalid once the callback completes.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_on_connection_setup_fn","page":"Home","title":"LibAwsHTTP.aws_websocket_on_connection_setup_fn","text":"Called when websocket setup is complete. Called exactly once on the websocket's event-loop thread. See aws_websocket_on_connection_setup_data.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_on_connection_shutdown_fn","page":"Home","title":"LibAwsHTTP.aws_websocket_on_connection_shutdown_fn","text":"Called when the websocket has finished shutting down. Called once on the websocket's event-loop thread if setup succeeded. If setup failed, this is never called.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_on_incoming_frame_begin_fn","page":"Home","title":"LibAwsHTTP.aws_websocket_on_incoming_frame_begin_fn","text":"Called when a new frame arrives. Invoked once per frame on the websocket's event-loop thread. Each incoming-frame-begin call will eventually be followed by an incoming-frame-complete call, before the next frame begins and before the websocket shuts down.\n\nReturn true to proceed normally. If false is returned, the websocket will read no further data, the frame will complete with an error-code, and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_on_incoming_frame_complete_fn","page":"Home","title":"LibAwsHTTP.aws_websocket_on_incoming_frame_complete_fn","text":"Called when done processing an incoming frame. If error_code is non-zero, an error occurred and the payload may not have been completely received. Invoked once per frame on the websocket's event-loop thread.\n\nReturn true to proceed normally. If false is returned, the websocket will read no further data and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_on_incoming_frame_payload_fn","page":"Home","title":"LibAwsHTTP.aws_websocket_on_incoming_frame_payload_fn","text":"Called repeatedly as payload data arrives. Invoked 0 or more times on the websocket's event-loop thread. Payload data will not be valid after this call, so copy if necessary. The payload data is always unmasked at this point.\n\nNOTE: If you created the websocket with manual_window_management set true, you must maintain the read window. Whenever the read window reaches 0, you will stop receiving anything. The websocket's initial_window_size determines the starting size of the read window. The read window shrinks as you receive the payload from \"data\" frames (TEXT, BINARY, and CONTINUATION). Use aws_websocket_increment_read_window() to increment the window again and keep frames flowing. Maintain a larger window to keep up high throughput. You only need to worry about the payload from \"data\" frames. The websocket automatically increments the window to account for any other incoming bytes, including other parts of a frame (opcode, payload-length, etc) and the payload of other frame types (PING, PONG, CLOSE).\n\nReturn true to proceed normally. If false is returned, the websocket will read no further data, the frame will complete with an error-code, and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_opcode","page":"Home","title":"LibAwsHTTP.aws_websocket_opcode","text":"aws_websocket_opcode\n\nOpcode describing the type of a websocket frame. RFC-6455 Section 5.2\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_outgoing_frame_complete_fn","page":"Home","title":"LibAwsHTTP.aws_websocket_outgoing_frame_complete_fn","text":"Called when a aws_websocket_send_frame() operation completes. error_code will be zero if the operation was successful. \"Success\" does not guarantee that the peer actually received or processed the frame. Invoked exactly once per sent frame on the websocket's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_send_frame_options","page":"Home","title":"LibAwsHTTP.aws_websocket_send_frame_options","text":"aws_websocket_send_frame_options\n\nOptions for sending a websocket frame. This structure is copied immediately by aws_websocket_send(). For descriptions of opcode, fin, and payload_length see in RFC-6455 Section 5.2.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_websocket_stream_outgoing_payload_fn","page":"Home","title":"LibAwsHTTP.aws_websocket_stream_outgoing_payload_fn","text":"Called repeatedly as the websocket's payload is streamed out. The user should write payload data to out_buf, up to available capacity. The websocket will mask this data for you, if necessary. Invoked repeatedly on the websocket's event-loop thread.\n\nReturn true to proceed normally. If false is returned, the websocket will send no further data, the frame will complete with an error-code, and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.proxy_env_var_settings","page":"Home","title":"LibAwsHTTP.proxy_env_var_settings","text":"proxy_env_var_settings\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.union (unnamed at /home/runner/.julia/artifacts/85685389a7cf65da8cc0602c40154726f3d3d455/include/aws/http/proxy.h:302:5)","page":"Home","title":"LibAwsHTTP.union (unnamed at /home/runner/.julia/artifacts/85685389a7cf65da8cc0602c40154726f3d3d455/include/aws/http/proxy.h:302:5)","text":"union (unnamed at /home/runner/.julia/artifacts/85685389a7cf65da8cc0602c40154726f3d3d455/include/aws/http/proxy.h:302:5)\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsHTTP.aws_crt_statistics_http1_channel_cleanup-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_crt_statistics_http1_channel_cleanup","text":"aws_crt_statistics_http1_channel_cleanup(stats)\n\nCleans up a http channel handler statistics struct\n\nPrototype\n\nvoid aws_crt_statistics_http1_channel_cleanup(struct aws_crt_statistics_http1_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_crt_statistics_http1_channel_init-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_crt_statistics_http1_channel_init","text":"aws_crt_statistics_http1_channel_init(stats)\n\nInitializes a http channel handler statistics struct\n\nPrototype\n\nint aws_crt_statistics_http1_channel_init(struct aws_crt_statistics_http1_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_crt_statistics_http1_channel_reset-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_crt_statistics_http1_channel_reset","text":"aws_crt_statistics_http1_channel_reset(stats)\n\nResets a http channel handler statistics struct's statistics\n\nPrototype\n\nvoid aws_crt_statistics_http1_channel_reset(struct aws_crt_statistics_http1_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_crt_statistics_http2_channel_init-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_crt_statistics_http2_channel_init","text":"aws_crt_statistics_http2_channel_init(stats)\n\nInitializes a HTTP/2 channel handler statistics struct\n\nPrototype\n\nvoid aws_crt_statistics_http2_channel_init(struct aws_crt_statistics_http2_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_crt_statistics_http2_channel_reset-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_crt_statistics_http2_channel_reset","text":"aws_crt_statistics_http2_channel_reset(stats)\n\nResets a HTTP/2 channel handler statistics struct's statistics\n\nPrototype\n\nvoid aws_crt_statistics_http2_channel_reset(struct aws_crt_statistics_http2_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_acquire","text":"aws_future_http_message_acquire(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_get_error-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_get_error","text":"aws_future_http_message_get_error(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_get_result_by_move-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_get_result_by_move","text":"aws_future_http_message_get_result_by_move(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_is_done-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_is_done","text":"aws_future_http_message_is_done(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_new-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_new","text":"aws_future_http_message_new(alloc)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_peek_result-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_peek_result","text":"aws_future_http_message_peek_result(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_register_callback","text":"aws_future_http_message_register_callback(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_register_callback_if_not_done","text":"aws_future_http_message_register_callback_if_not_done(future, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_register_channel_callback","text":"aws_future_http_message_register_channel_callback(future, channel, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_register_event_loop_callback","text":"aws_future_http_message_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_release","text":"aws_future_http_message_release(future)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_set_error-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_set_error","text":"aws_future_http_message_set_error(future, error_code)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_set_result_by_move-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_set_result_by_move","text":"aws_future_http_message_set_result_by_move(future, pointer_address)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_future_http_message_wait-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_future_http_message_wait","text":"aws_future_http_message_wait(future, timeout_ns)\n\nDocumentation not found.\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http1_stream_add_chunked_trailer-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http1_stream_add_chunked_trailer","text":"aws_http1_stream_add_chunked_trailer(http1_stream, trailing_headers)\n\nAdd a list of headers to be added as trailing headers sent after the last chunk is sent. a \"Trailer\" header field which indicates the fields present in the trailer.\n\nCertain headers are forbidden in the trailer (e.g., Transfer-Encoding, Content-Length, Host). See RFC-7541 Section 4.1.2 for more details.\n\nFor client streams, activate() must be called before any chunks are submitted.\n\nFor server streams, the response must be submitted before the trailer can be added\n\naws_http1_stream_add_chunked_trailer must be called before the final size 0 chunk, and at the moment can only be called once, though this could change if need be.\n\nReturns AWS_OP_SUCCESS if the chunk has been submitted.\n\nPrototype\n\nint aws_http1_stream_add_chunked_trailer( struct aws_http_stream *http1_stream, const struct aws_http_headers *trailing_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http1_stream_write_chunk-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http1_stream_write_chunk","text":"aws_http1_stream_write_chunk(http1_stream, options)\n\nSubmit a chunk of data to be sent on an HTTP/1.1 stream. The stream must have specified \"chunked\" in a \"transfer-encoding\" header, and the aws_http_message must NOT have any body stream set. For client streams, activate() must be called before any chunks are submitted. For server streams, the response must be submitted before any chunks. A final chunk with size 0 must be submitted to successfully complete the HTTP-stream.\n\nReturns AWS_OP_SUCCESS if the chunk has been submitted. The chunk's completion callback will be invoked when the HTTP-stream is done with the chunk data, whether or not it was successfully sent (see aws_http1_stream_write_chunk_complete_fn). The chunk data must remain valid until the completion callback is invoked.\n\nReturns AWS_OP_ERR and raises an error if the chunk could not be submitted. In this case, the chunk's completion callback will never be invoked. Note that it is always possible for the HTTP-stream to terminate unexpectedly prior to this call being made, in which case the error raised is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED.\n\nPrototype\n\nint aws_http1_stream_write_chunk( struct aws_http_stream *http1_stream, const struct aws_http1_chunk_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_change_settings-NTuple{5, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_change_settings","text":"aws_http2_connection_change_settings(http2_connection, settings_array, num_settings, on_completed, user_data)\n\nSend a SETTINGS frame (HTTP/2 only). SETTINGS will be applied locally when SETTINGS ACK is received from peer.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\nsettings_array: The array of settings to change. Note: each setting has its boundary.\nnum_settings: The num of settings to change in settings_array.\non_completed: Optional callback, see aws_http2_on_change_settings_complete_fn.\nuser_data: User-data pass to on_completed callback.\n\nPrototype\n\nint aws_http2_connection_change_settings( struct aws_http_connection *http2_connection, const struct aws_http2_setting *settings_array, size_t num_settings, aws_http2_on_change_settings_complete_fn *on_completed, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_get_local_settings-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_get_local_settings","text":"aws_http2_connection_get_local_settings(http2_connection, out_settings)\n\nGet the local settings we are using to affect the decoding.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\nout_settings: fixed size array of aws_http2_setting gets set to the local settings\n\nPrototype\n\nvoid aws_http2_connection_get_local_settings( const struct aws_http_connection *http2_connection, struct aws_http2_setting out_settings[AWS_HTTP2_SETTINGS_COUNT]);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_get_received_goaway-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_get_received_goaway","text":"aws_http2_connection_get_received_goaway(http2_connection, out_http2_error, out_last_stream_id)\n\nGet data about the latest GOAWAY frame received from peer (HTTP/2 only). If no GOAWAY has been received, or the GOAWAY payload is still in transmitting, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE will be raised.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\nout_http2_error: Gets set to HTTP/2 error code received in most recent GOAWAY.\nout_last_stream_id: Gets set to Last-Stream-ID received in most recent GOAWAY.\n\nPrototype\n\nint aws_http2_connection_get_received_goaway( struct aws_http_connection *http2_connection, uint32_t *out_http2_error, uint32_t *out_last_stream_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_get_remote_settings-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_get_remote_settings","text":"aws_http2_connection_get_remote_settings(http2_connection, out_settings)\n\nGet the settings received from remote peer, which we are using to restricts the message to send.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\nout_settings: fixed size array of aws_http2_setting gets set to the remote settings\n\nPrototype\n\nvoid aws_http2_connection_get_remote_settings( const struct aws_http_connection *http2_connection, struct aws_http2_setting out_settings[AWS_HTTP2_SETTINGS_COUNT]);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_get_sent_goaway-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_get_sent_goaway","text":"aws_http2_connection_get_sent_goaway(http2_connection, out_http2_error, out_last_stream_id)\n\nGet data about the latest GOAWAY frame sent to peer (HTTP/2 only). If no GOAWAY has been sent, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE will be raised. Note that GOAWAY frames are typically sent automatically by the connection during shutdown.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\nout_http2_error: Gets set to HTTP/2 error code sent in most recent GOAWAY.\nout_last_stream_id: Gets set to Last-Stream-ID sent in most recent GOAWAY.\n\nPrototype\n\nint aws_http2_connection_get_sent_goaway( struct aws_http_connection *http2_connection, uint32_t *out_http2_error, uint32_t *out_last_stream_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_ping-NTuple{4, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_ping","text":"aws_http2_connection_ping(http2_connection, optional_opaque_data, on_completed, user_data)\n\nSend a PING frame (HTTP/2 only). Round-trip-time is calculated when PING ACK is received from peer.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\noptional_opaque_data: Optional payload for PING frame. Must be NULL, or exactly 8 bytes (AWS_HTTP2_PING_DATA_SIZE). If NULL, the 8 byte payload will be all zeroes.\non_completed: Optional callback, invoked when PING ACK is received from peer, or when a connection error prevents the PING ACK from being received. Callback always fires on the connection's event-loop thread.\nuser_data: User-data pass to on_completed callback.\n\nPrototype\n\nint aws_http2_connection_ping( struct aws_http_connection *http2_connection, const struct aws_byte_cursor *optional_opaque_data, aws_http2_on_ping_complete_fn *on_completed, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_send_goaway-NTuple{4, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_send_goaway","text":"aws_http2_connection_send_goaway(http2_connection, http2_error, allow_more_streams, optional_debug_data)\n\nSend a custom GOAWAY frame (HTTP/2 only).\n\nNote that the connection automatically attempts to send a GOAWAY during shutdown (unless a GOAWAY with a valid Last-Stream-ID has already been sent).\n\nThis call can be used to gracefully warn the peer of an impending shutdown (http2_error=0, allow_more_streams=true), or to customize the final GOAWAY frame that is sent by this connection.\n\nThe other end may not receive the goaway, if the connection already closed.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\nhttp2_error: The HTTP/2 error code (RFC-7540 section 7) to send. enum [awshttp2error_code](@ref) lists official codes.\nallow_more_streams: If true, new peer-initiated streams will continue to be acknowledged and the GOAWAY's Last-Stream-ID will be set to a max value. If false, new peer-initiated streams will be ignored and the GOAWAY's Last-Stream-ID will be set to the latest acknowledged stream.\noptional_debug_data: Optional debug data to send. Size must not exceed 16KB.\n\nPrototype\n\nvoid aws_http2_connection_send_goaway( struct aws_http_connection *http2_connection, uint32_t http2_error, bool allow_more_streams, const struct aws_byte_cursor *optional_debug_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_connection_update_window-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_connection_update_window","text":"aws_http2_connection_update_window(http2_connection, increment_size)\n\nIncrement the connection's flow-control window to keep data flowing (HTTP/2 only).\n\nIf the connection was created with conn_manual_window_management set true, the flow-control window of the connection will shrink as body data is received for all the streams created on it. (headers, padding, and other metadata do not affect the window). The initial connection flow-control window is 65,535. Once the connection's flow-control window reaches to 0, all the streams on the connection stop receiving any further data.\n\nIf conn_manual_window_management is false, this call will have no effect. The connection maintains its flow-control windows such that no back-pressure is applied and data arrives as fast as possible.\n\nIf you are not connected, this call will have no effect.\n\nCrashes when the connection is not http2 connection. The limit of the Maximum Size is 2**31 - 1. If the increment size cause the connection flow window exceeds the Maximum size, this call will result in the connection lost.\n\nArguments\n\nhttp2_connection: HTTP/2 connection.\nincrement_size: The size to increment for the connection's flow control window\n\nPrototype\n\nvoid aws_http2_connection_update_window(struct aws_http_connection *http2_connection, uint32_t increment_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_get_request_authority-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_get_request_authority","text":"aws_http2_headers_get_request_authority(h2_headers, out_authority)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http2_headers_get_request_authority( const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_authority);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_get_request_method-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_get_request_method","text":"aws_http2_headers_get_request_method(h2_headers, out_method)\n\nGet the :method value (HTTP/2 headers only).\n\nPrototype\n\nint aws_http2_headers_get_request_method(const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_get_request_path-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_get_request_path","text":"aws_http2_headers_get_request_path(h2_headers, out_path)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http2_headers_get_request_path(const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_get_request_scheme-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_get_request_scheme","text":"aws_http2_headers_get_request_scheme(h2_headers, out_scheme)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http2_headers_get_request_scheme(const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_scheme);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_get_response_status-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_get_response_status","text":"aws_http2_headers_get_response_status(h2_headers, out_status_code)\n\nGet :status (response pseudo headers only). If no status is set, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE is raised.\n\nPrototype\n\nint aws_http2_headers_get_response_status(const struct aws_http_headers *h2_headers, int *out_status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_set_request_authority-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_set_request_authority","text":"aws_http2_headers_set_request_authority(h2_headers, authority)\n\nSet :authority (request pseudo headers only). The pseudo headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_authority(struct aws_http_headers *h2_headers, struct aws_byte_cursor authority);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_set_request_method-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_set_request_method","text":"aws_http2_headers_set_request_method(h2_headers, method)\n\nSet :method (HTTP/2 headers only). The headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_method(struct aws_http_headers *h2_headers, struct aws_byte_cursor method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_set_request_path-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_set_request_path","text":"aws_http2_headers_set_request_path(h2_headers, path)\n\nSet :path (request pseudo headers only). The pseudo headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_path(struct aws_http_headers *h2_headers, struct aws_byte_cursor path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_set_request_scheme-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_set_request_scheme","text":"aws_http2_headers_set_request_scheme(h2_headers, scheme)\n\nSet :scheme (request pseudo headers only). The pseudo headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_scheme(struct aws_http_headers *h2_headers, struct aws_byte_cursor scheme);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_headers_set_response_status-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_headers_set_response_status","text":"aws_http2_headers_set_response_status(h2_headers, status_code)\n\nSet :status (response pseudo headers only).\n\nPrototype\n\nint aws_http2_headers_set_response_status(struct aws_http_headers *h2_headers, int status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_message_new_from_http1-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_message_new_from_http1","text":"aws_http2_message_new_from_http1(alloc, http1_msg)\n\nCreate an HTTP/2 message from HTTP/1.1 message. pseudo headers will be created from the context and added to the headers of new message. Normal headers will be copied to the headers of new message. Note: - if host exist, it will be removed and :authority will be added using the information. - :scheme always defaults to \"https\". To use a different scheme create the HTTP/2 message directly\n\nPrototype\n\nstruct aws_http_message *aws_http2_message_new_from_http1( struct aws_allocator *alloc, const struct aws_http_message *http1_msg);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_message_new_request-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http2_message_new_request","text":"aws_http2_message_new_request(allocator)\n\nCreate a new HTTP/2 request message. pseudo headers need to be set from aws_http2_headers_set_request_* to the headers of the aws_http_message. Will be errored out if used in HTTP/1.1 connection.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http2_message_new_request(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_message_new_response-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http2_message_new_response","text":"aws_http2_message_new_response(allocator)\n\nCreate a new HTTP/2 response message. pseudo headers need to be set from aws_http2_headers_set_response_status to the headers of the aws_http_message. Will be errored out if used in HTTP/1.1 connection.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http2_message_new_response(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_get_received_reset_error_code-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_get_received_reset_error_code","text":"aws_http2_stream_get_received_reset_error_code(http2_stream, out_http2_error)\n\nGet the error code received in rst_stream. Only valid if the stream has completed, and an RST_STREAM frame has received.\n\nArguments\n\nhttp2_stream: HTTP/2 stream.\nout_http2_error: Gets to set to HTTP/2 error code received in rst_stream.\n\nPrototype\n\nint aws_http2_stream_get_received_reset_error_code(struct aws_http_stream *http2_stream, uint32_t *out_http2_error);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_get_sent_reset_error_code-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_get_sent_reset_error_code","text":"aws_http2_stream_get_sent_reset_error_code(http2_stream, out_http2_error)\n\nGet the HTTP/2 error code sent in the RST_STREAM frame (HTTP/2 only). Only valid if the stream has completed, and has sent an RST_STREAM frame.\n\nArguments\n\nhttp2_stream: HTTP/2 stream.\nout_http2_error: Gets to set to HTTP/2 error code sent in rst_stream.\n\nPrototype\n\nint aws_http2_stream_get_sent_reset_error_code(struct aws_http_stream *http2_stream, uint32_t *out_http2_error);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_acquire","text":"aws_http2_stream_manager_acquire(manager)\n\nAcquire a refcount from the stream manager, stream manager will start to destroy after the refcount drops to zero. NULL is acceptable. Initial refcount after new is 1.\n\nArguments\n\nmanager:\n\nReturns\n\nThe same pointer acquiring.\n\nPrototype\n\nstruct aws_http2_stream_manager *aws_http2_stream_manager_acquire(struct aws_http2_stream_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_acquire_stream-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_acquire_stream","text":"aws_http2_stream_manager_acquire_stream(http2_stream_manager, acquire_stream_option)\n\nAcquire a stream from stream manager asynchronously.\n\nArguments\n\nhttp2_stream_manager:\nacquire_stream_option: see aws_http2_stream_manager_acquire_stream_options\n\nPrototype\n\nvoid aws_http2_stream_manager_acquire_stream( struct aws_http2_stream_manager *http2_stream_manager, const struct aws_http2_stream_manager_acquire_stream_options *acquire_stream_option);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_fetch_metrics-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_fetch_metrics","text":"aws_http2_stream_manager_fetch_metrics(http2_stream_manager, out_metrics)\n\nFetch the current metrics from stream manager.\n\nArguments\n\nhttp2_stream_manager:\nout_metrics: The metrics to be fetched\n\nPrototype\n\nvoid aws_http2_stream_manager_fetch_metrics( const struct aws_http2_stream_manager *http2_stream_manager, struct aws_http_manager_metrics *out_metrics);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_new-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_new","text":"aws_http2_stream_manager_new(allocator, options)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_http2_stream_manager *aws_http2_stream_manager_new( struct aws_allocator *allocator, const struct aws_http2_stream_manager_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_manager_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_manager_release","text":"aws_http2_stream_manager_release(manager)\n\nRelease a refcount from the stream manager, stream manager will start to destroy after the refcount drops to zero. NULL is acceptable. Initial refcount after new is 1.\n\nArguments\n\nmanager:\n\nReturns\n\nNULL\n\nPrototype\n\nstruct aws_http2_stream_manager *aws_http2_stream_manager_release(struct aws_http2_stream_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_reset-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_reset","text":"aws_http2_stream_reset(http2_stream, http2_error)\n\nReset the HTTP/2 stream (HTTP/2 only). Note that if the stream closes before this async call is fully processed, the RST_STREAM frame will not be sent.\n\nArguments\n\nhttp2_stream: HTTP/2 stream.\nhttp2_error: aws_http2_error_code. Reason to reset the stream.\n\nPrototype\n\nint aws_http2_stream_reset(struct aws_http_stream *http2_stream, uint32_t http2_error);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http2_stream_write_data-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http2_stream_write_data","text":"aws_http2_stream_write_data(http2_stream, options)\n\nThe stream must have specified http2_use_manual_data_writes during request creation. For client streams, activate() must be called before any frames are submitted. For server streams, the response headers must be submitted before any frames. A write with options that has end_stream set to be true will end the stream and prevent any further write.\n\nTypical usage will be something like: options.http2_use_manual_data_writes = true; stream = aws_http_connection_make_request(connection, &options); aws_http_stream_activate(stream); ... struct aws_http2_stream_write_data_options write; aws_http2_stream_write_data(stream, &write); ... struct aws_http2_stream_write_data_options last_write; last_write.end_stream = true; aws_http2_stream_write_data(stream, &write); ... aws_http_stream_release(stream);\n\nReturns\n\nAWS_OP_SUCCESS if the write was queued AWS_OP_ERROR indicating the attempt raised an error code. AWS_ERROR_INVALID_STATE will be raised for invalid usage. AWS_ERROR_HTTP_STREAM_HAS_COMPLETED will be raised if the stream ended for reasons behind the scenes.\n\nPrototype\n\nint aws_http2_stream_write_data( struct aws_http_stream *http2_stream, const struct aws_http2_stream_write_data_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_alpn_map_init-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_alpn_map_init","text":"aws_http_alpn_map_init(allocator, map)\n\nInitialize an empty hash-table that maps struct aws\\_string * to enum [awshttpversion](@ref). This map can used in aws_http_client_connections_options.alpn_string_map.\n\nPrototype\n\nint aws_http_alpn_map_init(struct aws_allocator *allocator, struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_alpn_map_init_copy-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_alpn_map_init_copy","text":"aws_http_alpn_map_init_copy(allocator, dest, src)\n\nInitialize an map copied from the *src map, which maps struct aws\\_string * to enum [awshttpversion](@ref).\n\nPrototype\n\nint aws_http_alpn_map_init_copy( struct aws_allocator *allocator, struct aws_hash_table *dest, struct aws_hash_table *src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_client_connect-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_client_connect","text":"aws_http_client_connect(options)\n\nAsynchronously establish a client connection. The on_setup callback is invoked when the operation has created a connection or failed.\n\nPrototype\n\nint aws_http_client_connect(const struct aws_http_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_close-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_close","text":"aws_http_connection_close(connection)\n\nBegin shutdown sequence of the connection if it hasn't already started. This will schedule shutdown tasks on the EventLoop that may send HTTP/TLS/TCP shutdown messages to peers if necessary, and will eventually cause internal connection memory to stop being accessed and on_shutdown() callback to be called.\n\nIt's safe to call this function regardless of the connection state as long as you hold a reference to the connection.\n\nPrototype\n\nvoid aws_http_connection_close(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_configure_server-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_configure_server","text":"aws_http_connection_configure_server(connection, options)\n\nConfigure a server connection. This must be called from the server's on_incoming_connection callback.\n\nPrototype\n\nint aws_http_connection_configure_server( struct aws_http_connection *connection, const struct aws_http_server_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_get_channel-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_get_channel","text":"aws_http_connection_get_channel(connection)\n\nReturns the channel hosting the HTTP connection. Do not expose this function to language bindings.\n\nPrototype\n\nstruct aws_channel *aws_http_connection_get_channel(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_get_remote_endpoint-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_get_remote_endpoint","text":"aws_http_connection_get_remote_endpoint(connection)\n\nReturns the remote endpoint of the HTTP connection.\n\nPrototype\n\nconst struct aws_socket_endpoint *aws_http_connection_get_remote_endpoint(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_get_version-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_get_version","text":"aws_http_connection_get_version(connection)\n\nDocumentation not found.\n\nPrototype\n\nenum aws_http_version aws_http_connection_get_version(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_is_client-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_is_client","text":"aws_http_connection_is_client(connection)\n\nReturns true if this is a client connection.\n\nPrototype\n\nbool aws_http_connection_is_client(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_is_open-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_is_open","text":"aws_http_connection_is_open(connection)\n\nReturns true unless the connection is closed or closing.\n\nPrototype\n\nbool aws_http_connection_is_open(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_is_server-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_is_server","text":"aws_http_connection_is_server(connection)\n\nReturns true if this is a server connection.\n\nPrototype\n\nbool aws_http_connection_is_server(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_make_request-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_make_request","text":"aws_http_connection_make_request(client_connection, options)\n\nCreate a stream, with a client connection sending a request. The request does not start sending automatically once the stream is created. You must call aws_http_stream_activate to begin execution of the request.\n\nThe options are copied during this call.\n\nTip for language bindings: Do not bind the options struct. Use something more natural for your language, such as Builder Pattern in Java, or Python's ability to take many optional arguments by name.\n\nNote: The header of the request will be sent as it is when the message to send protocol matches the protocol of the connection. - No user-agent will be added. - No security check will be enforced. eg: referer header privacy should be enforced by the user-agent who adds the header - When HTTP/1 message sent on HTTP/2 connection, aws_http2_message_new_from_http1 will be applied under the hood. - When HTTP/2 message sent on HTTP/1 connection, no change will be made.\n\nPrototype\n\nstruct aws_http_stream *aws_http_connection_make_request( struct aws_http_connection *client_connection, const struct aws_http_make_request_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_manager_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_acquire","text":"aws_http_connection_manager_acquire(manager)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_http_connection_manager_acquire(struct aws_http_connection_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_manager_acquire_connection-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_acquire_connection","text":"aws_http_connection_manager_acquire_connection(manager, callback, user_data)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_http_connection_manager_acquire_connection( struct aws_http_connection_manager *manager, aws_http_connection_manager_on_connection_setup_fn *callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_manager_fetch_metrics-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_fetch_metrics","text":"aws_http_connection_manager_fetch_metrics(manager, out_metrics)\n\nFetch the current manager metrics from connection manager.\n\nPrototype\n\nvoid aws_http_connection_manager_fetch_metrics( const struct aws_http_connection_manager *manager, struct aws_http_manager_metrics *out_metrics);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_manager_new-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_new","text":"aws_http_connection_manager_new(allocator, options)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_http_connection_manager *aws_http_connection_manager_new( struct aws_allocator *allocator, const struct aws_http_connection_manager_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_manager_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_release","text":"aws_http_connection_manager_release(manager)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_http_connection_manager_release(struct aws_http_connection_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_manager_release_connection-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_manager_release_connection","text":"aws_http_connection_manager_release_connection(manager, connection)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http_connection_manager_release_connection( struct aws_http_connection_manager *manager, struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_new_requests_allowed-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_new_requests_allowed","text":"aws_http_connection_new_requests_allowed(connection)\n\nReturn whether the connection can make a new requests. If false, then a new connection must be established to make further requests.\n\nPrototype\n\nbool aws_http_connection_new_requests_allowed(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_release","text":"aws_http_connection_release(connection)\n\nUsers must release the connection when they are done with it. The connection's memory cannot be reclaimed until this is done. If the connection was not already shutting down, it will be shut down.\n\nUsers should always wait for the on_shutdown() callback to be called before releasing any data passed to the http_connection (Eg aws_tls_connection_options, aws_socket_options) otherwise there will be race conditions between http_connection shutdown tasks and memory release tasks, causing Segfaults.\n\nPrototype\n\nvoid aws_http_connection_release(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_connection_stop_new_requests-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_connection_stop_new_requests","text":"aws_http_connection_stop_new_requests(connection)\n\nStop accepting new requests for the connection. It will NOT start the shutdown process for the connection. The requests that are already open can still wait to be completed, but new requests will fail to be created,\n\nPrototype\n\nvoid aws_http_connection_stop_new_requests(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_header_name_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_header_name_eq","text":"aws_http_header_name_eq(name_a, name_b)\n\nReturn whether both names are equivalent. This is a case-insensitive string comparison.\n\nExample Matches: \"Content-Length\" == \"content-length\" // upper or lower case ok\n\nExample Mismatches: \"Content-Length\" != \" Content-Length\" // leading whitespace bad\n\nPrototype\n\nbool aws_http_header_name_eq(struct aws_byte_cursor name_a, struct aws_byte_cursor name_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_acquire","text":"aws_http_headers_acquire(headers)\n\nAcquire a hold on the object, preventing it from being deleted until aws_http_headers_release() is called by all those with a hold on it.\n\nPrototype\n\nvoid aws_http_headers_acquire(struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_add-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_add","text":"aws_http_headers_add(headers, name, value)\n\nAdd a header. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_add(struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_add_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_add_array","text":"aws_http_headers_add_array(headers, array, count)\n\nAdd an array of headers. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_add_array(struct aws_http_headers *headers, const struct aws_http_header *array, size_t count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_add_header-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_add_header","text":"aws_http_headers_add_header(headers, header)\n\nAdd a header. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_add_header(struct aws_http_headers *headers, const struct aws_http_header *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_clear-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_clear","text":"aws_http_headers_clear(headers)\n\nClear all headers.\n\nPrototype\n\nvoid aws_http_headers_clear(struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_count-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_count","text":"aws_http_headers_count(headers)\n\nGet the total number of headers.\n\nPrototype\n\nsize_t aws_http_headers_count(const struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_erase-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_erase","text":"aws_http_headers_erase(headers, name)\n\nRemove all headers with this name. AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if no headers with this name are found.\n\nPrototype\n\nint aws_http_headers_erase(struct aws_http_headers *headers, struct aws_byte_cursor name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_erase_index-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_erase_index","text":"aws_http_headers_erase_index(headers, index)\n\nRemove the header at the specified index.\n\nAWS_ERROR_INVALID_INDEX is raised if the index is invalid.\n\nPrototype\n\nint aws_http_headers_erase_index(struct aws_http_headers *headers, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_erase_value-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_erase_value","text":"aws_http_headers_erase_value(headers, name, value)\n\nRemove the first header found with this name and value. AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if no such header is found.\n\nPrototype\n\nint aws_http_headers_erase_value( struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_get-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_get","text":"aws_http_headers_get(headers, name, out_value)\n\nGet the first value for this name, ignoring any additional values. AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if the name is not found.\n\nPrototype\n\nint aws_http_headers_get( const struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor *out_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_get_all-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_get_all","text":"aws_http_headers_get_all(headers, name)\n\nGet all values with this name, combined into one new aws_string that you are responsible for destroying. If there are multiple headers with this name, their values are appended with comma-separators. If there are no headers with this name, NULL is returned and AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised.\n\nPrototype\n\nstruct aws_string *aws_http_headers_get_all(const struct aws_http_headers *headers, struct aws_byte_cursor name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_get_index-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_get_index","text":"aws_http_headers_get_index(headers, index, out_header)\n\nGet the header at the specified index. The index of a given header may change any time headers are modified. When iterating headers, the following ordering rules apply:\n\nHeaders with the same name will always be in the same order, relative to one another. If \"A: one\" is added before \"A: two\", then \"A: one\" will always precede \"A: two\".\nHeaders with different names could be in any order, relative to one another. If \"A: one\" is seen before \"B: bee\" in one iteration, you might see \"B: bee\" before \"A: one\" on the next.\n\nAWS_ERROR_INVALID_INDEX is raised if the index is invalid.\n\nPrototype\n\nint aws_http_headers_get_index( const struct aws_http_headers *headers, size_t index, struct aws_http_header *out_header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_has-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_has","text":"aws_http_headers_has(headers, name)\n\nTest if header name exists or not in headers\n\nPrototype\n\nbool aws_http_headers_has(const struct aws_http_headers *headers, struct aws_byte_cursor name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_new-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_new","text":"aws_http_headers_new(allocator)\n\nCreate a new headers object. The caller has a hold on the object and must call aws_http_headers_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_headers *aws_http_headers_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_release","text":"aws_http_headers_release(headers)\n\nRelease a hold on the object. The object is deleted when all holds on it are released.\n\nPrototype\n\nvoid aws_http_headers_release(struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_headers_set-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_headers_set","text":"aws_http_headers_set(headers, name, value)\n\nSet a header value. The header is added if necessary and any existing values for this name are removed. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_set(struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_library_clean_up-Tuple{}","page":"Home","title":"LibAwsHTTP.aws_http_library_clean_up","text":"aws_http_library_clean_up()\n\nClean up internal datastructures used by aws-c-http. Must not be called until application is done using functionality in aws-c-http.\n\nPrototype\n\nvoid aws_http_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_library_init-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_library_init","text":"aws_http_library_init(alloc)\n\nInitializes internal datastructures used by aws-c-http. Must be called before using any functionality in aws-c-http.\n\nPrototype\n\nvoid aws_http_library_init(struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_acquire","text":"aws_http_message_acquire(message)\n\nAcquire a hold on the object, preventing it from being deleted until aws_http_message_release() is called by all those with a hold on it.\n\nThis function returns the passed in message (possibly NULL) so that acquire-and-assign can be done with a single statement.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_acquire(struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_add_header-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_add_header","text":"aws_http_message_add_header(message, header)\n\nAdd a header to the end of the array. The message makes its own copy of the underlying strings.\n\nPrototype\n\nint aws_http_message_add_header(struct aws_http_message *message, struct aws_http_header header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_add_header_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_add_header_array","text":"aws_http_message_add_header_array(message, headers, num_headers)\n\nAdd an array of headers to the end of the header array. The message makes its own copy of the underlying strings.\n\nThis is a helper function useful when it's easier to define headers as a stack array, rather than calling add_header repeatedly.\n\nPrototype\n\nint aws_http_message_add_header_array( struct aws_http_message *message, const struct aws_http_header *headers, size_t num_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_destroy-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_destroy","text":"aws_http_message_destroy(message)\n\nDeprecated. This is equivalent to aws_http_message_release().\n\nPrototype\n\nvoid aws_http_message_destroy(struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_erase_header-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_erase_header","text":"aws_http_message_erase_header(message, index)\n\nRemove the header at the specified index. Headers after this index are all shifted back one position.\n\nThis function cannot fail if a valid index is provided. Otherwise, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nint aws_http_message_erase_header(struct aws_http_message *message, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_body_stream-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_body_stream","text":"aws_http_message_get_body_stream(message)\n\nGet the body stream. Returns NULL if no body stream is set.\n\nPrototype\n\nstruct aws_input_stream *aws_http_message_get_body_stream(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_const_headers-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_const_headers","text":"aws_http_message_get_const_headers(message)\n\nGet the message's const aws_http_headers.\n\nPrototype\n\nconst struct aws_http_headers *aws_http_message_get_const_headers(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_header-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_header","text":"aws_http_message_get_header(message, out_header, index)\n\nGet the header at the specified index. This function cannot fail if a valid index is provided. Otherwise, AWS_ERROR_INVALID_INDEX will be raised.\n\nThe underlying strings are stored within the message.\n\nPrototype\n\nint aws_http_message_get_header( const struct aws_http_message *message, struct aws_http_header *out_header, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_header_count-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_header_count","text":"aws_http_message_get_header_count(message)\n\nGet the number of headers.\n\nPrototype\n\nsize_t aws_http_message_get_header_count(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_headers-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_headers","text":"aws_http_message_get_headers(message)\n\nThis datastructure has more functions for inspecting and modifying headers than are available on the aws_http_message datastructure.\n\nPrototype\n\nstruct aws_http_headers *aws_http_message_get_headers(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_protocol_version-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_protocol_version","text":"aws_http_message_get_protocol_version(message)\n\nGet the protocol version of the http message.\n\nPrototype\n\nenum aws_http_version aws_http_message_get_protocol_version(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_request_method-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_request_method","text":"aws_http_message_get_request_method(request_message, out_method)\n\nGet the method (request messages only).\n\nPrototype\n\nint aws_http_message_get_request_method( const struct aws_http_message *request_message, struct aws_byte_cursor *out_method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_request_path-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_request_path","text":"aws_http_message_get_request_path(request_message, out_path)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http_message_get_request_path(const struct aws_http_message *request_message, struct aws_byte_cursor *out_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_get_response_status-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_get_response_status","text":"aws_http_message_get_response_status(response_message, out_status_code)\n\nGet the status code (response messages only). If no status is set, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE is raised.\n\nPrototype\n\nint aws_http_message_get_response_status(const struct aws_http_message *response_message, int *out_status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_is_request-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_is_request","text":"aws_http_message_is_request(message)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_http_message_is_request(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_is_response-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_is_response","text":"aws_http_message_is_response(message)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_http_message_is_response(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_new_request-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_new_request","text":"aws_http_message_new_request(allocator)\n\nCreate a new HTTP/1.1 request message. The message is blank, all properties (method, path, etc) must be set individually. If HTTP/1.1 message used in HTTP/2 connection, the transformation will be automatically applied. A HTTP/2 message will created and sent based on the HTTP/1.1 message.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_request(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_new_request_with_headers-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_new_request_with_headers","text":"aws_http_message_new_request_with_headers(allocator, existing_headers)\n\nLike aws_http_message_new_request(), but uses existing aws_http_headers instead of creating a new one. Acquires a hold on the headers, and releases it when the request is destroyed.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_request_with_headers( struct aws_allocator *allocator, struct aws_http_headers *existing_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_new_response-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_new_response","text":"aws_http_message_new_response(allocator)\n\nCreate a new HTTP/1.1 response message. The message is blank, all properties (status, headers, etc) must be set individually.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_response(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_new_websocket_handshake_request-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_new_websocket_handshake_request","text":"aws_http_message_new_websocket_handshake_request(allocator, path, host)\n\nCreate request with all required fields for a websocket upgrade request. The method and path are set, and the the following headers are added:\n\nHost: <host> Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: <base64 encoding of 16 random bytes> Sec-WebSocket-Version: 13\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_websocket_handshake_request( struct aws_allocator *allocator, struct aws_byte_cursor path, struct aws_byte_cursor host);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_release","text":"aws_http_message_release(message)\n\nRelease a hold on the object. The object is deleted when all holds on it are released.\n\nThis function always returns NULL so that release-and-assign-NULL can be done with a single statement.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_release(struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_set_body_stream-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_set_body_stream","text":"aws_http_message_set_body_stream(message, body_stream)\n\nSet the body stream. NULL is an acceptable value for messages with no body. Note: The message does NOT take ownership of the body stream. The stream must not be destroyed until the message is complete.\n\nPrototype\n\nvoid aws_http_message_set_body_stream(struct aws_http_message *message, struct aws_input_stream *body_stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_set_request_method-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_set_request_method","text":"aws_http_message_set_request_method(request_message, method)\n\nSet the method (request messages only). The request makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http_message_set_request_method(struct aws_http_message *request_message, struct aws_byte_cursor method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_set_request_path-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_set_request_path","text":"aws_http_message_set_request_path(request_message, path)\n\nSet the path-and-query value (request messages only). The request makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http_message_set_request_path(struct aws_http_message *request_message, struct aws_byte_cursor path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_message_set_response_status-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_message_set_response_status","text":"aws_http_message_set_response_status(response_message, status_code)\n\nSet the status code (response messages only).\n\nPrototype\n\nint aws_http_message_set_response_status(struct aws_http_message *response_message, int status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_options_validate_proxy_configuration-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_options_validate_proxy_configuration","text":"aws_http_options_validate_proxy_configuration(options)\n\nChecks http proxy options for correctness\n\nPrototype\n\nint aws_http_options_validate_proxy_configuration(const struct aws_http_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_config_destroy-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config_destroy","text":"aws_http_proxy_config_destroy(config)\n\nDestroys an http proxy configuration\n\nArguments\n\nconfig: http proxy configuration to destroy\n\nPrototype\n\nvoid aws_http_proxy_config_destroy(struct aws_http_proxy_config *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_config_new_clone-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config_new_clone","text":"aws_http_proxy_config_new_clone(allocator, proxy_config)\n\nClones an existing proxy configuration. A refactor could remove this (do a \"move\" between the old and new user data in the one spot it's used) but that should wait until we have better test cases for the logic where this gets invoked (ntlm/kerberos chains).\n\nArguments\n\nallocator: memory allocator to use\nproxy_config: http proxy configuration to clone\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_clone( struct aws_allocator *allocator, const struct aws_http_proxy_config *proxy_config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_config_new_from_connection_options-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config_new_from_connection_options","text":"aws_http_proxy_config_new_from_connection_options(allocator, options)\n\nCreate a persistent proxy configuration from http connection options\n\nArguments\n\nallocator: memory allocator to use\noptions: http connection options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_connection_options( struct aws_allocator *allocator, const struct aws_http_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_config_new_from_manager_options-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config_new_from_manager_options","text":"aws_http_proxy_config_new_from_manager_options(allocator, options)\n\nCreate a persistent proxy configuration from http connection manager options\n\nArguments\n\nallocator: memory allocator to use\noptions: http connection manager options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_manager_options( struct aws_allocator *allocator, const struct aws_http_connection_manager_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_config_new_from_proxy_options-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config_new_from_proxy_options","text":"aws_http_proxy_config_new_from_proxy_options(allocator, options)\n\nCreate a persistent proxy configuration from non-persistent proxy options. Legacy connection type of proxy options will be rejected.\n\nArguments\n\nallocator: memory allocator to use\noptions: http proxy options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_proxy_options( struct aws_allocator *allocator, const struct aws_http_proxy_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_config_new_from_proxy_options_with_tls_info-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config_new_from_proxy_options_with_tls_info","text":"aws_http_proxy_config_new_from_proxy_options_with_tls_info(allocator, proxy_options, is_tls_connection)\n\nCreate a persistent proxy configuration from non-persistent proxy options.\n\nArguments\n\nallocator: memory allocator to use\noptions: http proxy options to source proxy configuration from\nis_tls_connection: tls connection info of the main connection to determine connection_type when the connection_type is legacy.\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_proxy_options_with_tls_info( struct aws_allocator *allocator, const struct aws_http_proxy_options *proxy_options, bool is_tls_connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_config_new_tunneling_from_proxy_options-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_config_new_tunneling_from_proxy_options","text":"aws_http_proxy_config_new_tunneling_from_proxy_options(allocator, options)\n\nCreate a persistent proxy configuration from non-persistent proxy options. The resulting proxy configuration assumes a tunneling connection type.\n\nArguments\n\nallocator: memory allocator to use\noptions: http proxy options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_tunneling_from_proxy_options( struct aws_allocator *allocator, const struct aws_http_proxy_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator_acquire","text":"aws_http_proxy_negotiator_acquire(proxy_negotiator)\n\nTake a reference to an http proxy negotiator\n\nArguments\n\nproxy_negotiator: negotiator to take a reference to\n\nReturns\n\nthe strategy\n\nPrototype\n\nstruct aws_http_proxy_negotiator *aws_http_proxy_negotiator_acquire(struct aws_http_proxy_negotiator *proxy_negotiator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_negotiator_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_negotiator_release","text":"aws_http_proxy_negotiator_release(proxy_negotiator)\n\nRelease a reference to an http proxy negotiator\n\nArguments\n\nproxy_negotiator: negotiator to release a reference to\n\nPrototype\n\nvoid aws_http_proxy_negotiator_release(struct aws_http_proxy_negotiator *proxy_negotiator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_new_socket_channel-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_new_socket_channel","text":"aws_http_proxy_new_socket_channel(channel_options, proxy_options)\n\nEstablish an arbitrary protocol connection through an http proxy via tunneling CONNECT. Alpn is not required for this connection process to succeed, but we encourage its use if available.\n\nArguments\n\nchannel_options: configuration options for the socket level connection\nproxy_options: configuration options for the proxy connection\n\nReturns\n\nAWS_OP_SUCCESS if the asynchronous channel kickoff succeeded, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_http_proxy_new_socket_channel( struct aws_socket_channel_bootstrap_options *channel_options, const struct aws_http_proxy_options *proxy_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_options_init_from_config-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_options_init_from_config","text":"aws_http_proxy_options_init_from_config(options, config)\n\nInitializes non-persistent http proxy options from a persistent http proxy configuration\n\nArguments\n\noptions: http proxy options to initialize\nconfig: the http proxy config to use as an initialization source\n\nPrototype\n\nvoid aws_http_proxy_options_init_from_config( struct aws_http_proxy_options *options, const struct aws_http_proxy_config *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_acquire","text":"aws_http_proxy_strategy_acquire(proxy_strategy)\n\nTake a reference to an http proxy strategy\n\nArguments\n\nproxy_strategy: strategy to take a reference to\n\nReturns\n\nthe strategy\n\nPrototype\n\nstruct aws_http_proxy_strategy *aws_http_proxy_strategy_acquire(struct aws_http_proxy_strategy *proxy_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_create_negotiator-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_create_negotiator","text":"aws_http_proxy_strategy_create_negotiator(strategy, allocator)\n\nCreates a new proxy negotiator from a proxy strategy\n\nArguments\n\nallocator: memory allocator to use\nstrategy: strategy to creation a new negotiator for\n\nReturns\n\na new proxy negotiator if successful, otherwise NULL\n\nPrototype\n\nstruct aws_http_proxy_negotiator *aws_http_proxy_strategy_create_negotiator( struct aws_http_proxy_strategy *strategy, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_new_basic_auth-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_new_basic_auth","text":"aws_http_proxy_strategy_new_basic_auth(allocator, config)\n\nA constructor for a proxy strategy that performs basic authentication by adding the appropriate header and header value to requests or CONNECT requests.\n\nArguments\n\nallocator: memory allocator to use\nconfig: basic authentication configuration info\n\nReturns\n\na new proxy strategy if successfully constructed, otherwise NULL\n\nPrototype\n\nstruct aws_http_proxy_strategy *aws_http_proxy_strategy_new_basic_auth( struct aws_allocator *allocator, struct aws_http_proxy_strategy_basic_auth_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_new_tunneling_adaptive-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_new_tunneling_adaptive","text":"aws_http_proxy_strategy_new_tunneling_adaptive(allocator, config)\n\nConstructor for an adaptive tunneling proxy strategy. This strategy attempts a vanilla CONNECT and if that fails it may make followup CONNECT attempts using kerberos or ntlm tokens, based on configuration and proxy response properties.\n\nArguments\n\nallocator: memory allocator to use\nconfig: configuration options for the strategy\n\nReturns\n\na new proxy strategy if successfully constructed, otherwise NULL\n\nPrototype\n\nstruct aws_http_proxy_strategy *aws_http_proxy_strategy_new_tunneling_adaptive( struct aws_allocator *allocator, struct aws_http_proxy_strategy_tunneling_adaptive_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_proxy_strategy_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_proxy_strategy_release","text":"aws_http_proxy_strategy_release(proxy_strategy)\n\nRelease a reference to an http proxy strategy\n\nArguments\n\nproxy_strategy: strategy to release a reference to\n\nPrototype\n\nvoid aws_http_proxy_strategy_release(struct aws_http_proxy_strategy *proxy_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_server_get_listener_endpoint-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_server_get_listener_endpoint","text":"aws_http_server_get_listener_endpoint(server)\n\nReturns the local listener endpoint of the HTTP server. Only valid as long as the server remains valid.\n\nPrototype\n\nconst struct aws_socket_endpoint *aws_http_server_get_listener_endpoint(const struct aws_http_server *server);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_server_new-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_server_new","text":"aws_http_server_new(options)\n\nCreate server, a listening socket that accepts incoming connections.\n\nPrototype\n\nstruct aws_http_server *aws_http_server_new(const struct aws_http_server_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_server_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_server_release","text":"aws_http_server_release(server)\n\nRelease the server. It will close the listening socket and all the connections existing in the server. The on_destroy_complete will be invoked when the destroy operation completes\n\nPrototype\n\nvoid aws_http_server_release(struct aws_http_server *server);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_status_text-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_status_text","text":"aws_http_status_text(status_code)\n\nReturns the description of common status codes. Ex: 404 -> \"Not Found\" An empty string is returned if the status code is not recognized.\n\nPrototype\n\nconst char *aws_http_status_text(int status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_acquire","text":"aws_http_stream_acquire(stream)\n\nAcquire refcount on the stream to prevent it from being cleaned up until it is released.\n\nPrototype\n\nstruct aws_http_stream *aws_http_stream_acquire(struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_activate-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_activate","text":"aws_http_stream_activate(stream)\n\nOnly used for client initiated streams (immediately following a call to aws_http_connection_make_request).\n\nActivates the request's outgoing stream processing.\n\nPrototype\n\nint aws_http_stream_activate(struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_cancel-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_cancel","text":"aws_http_stream_cancel(stream, error_code)\n\nCancel the stream in flight. For HTTP/1.1 streams, it's equivalent to closing the connection. For HTTP/2 streams, it's equivalent to calling reset on the stream with AWS_HTTP2_ERR_CANCEL.\n\nthe stream will complete with the error code provided, unless the stream is already completing for other reasons, or the stream is not activated, in which case this call will have no impact.\n\nPrototype\n\nvoid aws_http_stream_cancel(struct aws_http_stream *stream, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_get_connection-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_get_connection","text":"aws_http_stream_get_connection(stream)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_http_connection *aws_http_stream_get_connection(const struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_get_id-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_get_id","text":"aws_http_stream_get_id(stream)\n\nGets the HTTP/2 id associated with a stream. Even h1 streams have an id (using the same allocation procedure as http/2) for easier tracking purposes. For client streams, this will only be non-zero after a successful call to aws_http_stream_activate()\n\nPrototype\n\nuint32_t aws_http_stream_get_id(const struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_get_incoming_request_method-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_get_incoming_request_method","text":"aws_http_stream_get_incoming_request_method(stream, out_method)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http_stream_get_incoming_request_method( const struct aws_http_stream *stream, struct aws_byte_cursor *out_method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_get_incoming_request_uri-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_get_incoming_request_uri","text":"aws_http_stream_get_incoming_request_uri(stream, out_uri)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http_stream_get_incoming_request_uri(const struct aws_http_stream *stream, struct aws_byte_cursor *out_uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_get_incoming_response_status-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_get_incoming_response_status","text":"aws_http_stream_get_incoming_response_status(stream, out_status)\n\nDocumentation not found.\n\nPrototype\n\nint aws_http_stream_get_incoming_response_status(const struct aws_http_stream *stream, int *out_status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_new_server_request_handler-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_new_server_request_handler","text":"aws_http_stream_new_server_request_handler(options)\n\nCreate a stream, with a server connection receiving and responding to a request. This function can only be called from the aws_http_on_incoming_request_fn callback. aws_http_stream_send_response() should be used to send a response.\n\nPrototype\n\nstruct aws_http_stream *aws_http_stream_new_server_request_handler( const struct aws_http_request_handler_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_release","text":"aws_http_stream_release(stream)\n\nUsers must release the stream when they are done with it, or its memory will never be cleaned up. This will not cancel the stream, its callbacks will still fire if the stream is still in progress.\n\nTips for language bindings: - Invoke this from the wrapper class's finalizer/destructor. - Do not let the wrapper class be destroyed until on_complete() has fired.\n\nPrototype\n\nvoid aws_http_stream_release(struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_send_response-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_send_response","text":"aws_http_stream_send_response(stream, response)\n\nSend response (only callable from \"request handler\" streams) The response object must stay alive at least until the stream's on_complete is called.\n\nPrototype\n\nint aws_http_stream_send_response(struct aws_http_stream *stream, struct aws_http_message *response);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_http_stream_update_window-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_http_stream_update_window","text":"aws_http_stream_update_window(stream, increment_size)\n\nIncrement the stream's flow-control window to keep data flowing.\n\nIf the connection was created with manual_window_management set true, the flow-control window of each stream will shrink as body data is received (headers, padding, and other metadata do not affect the window). The connection's initial_window_size determines the starting size of each stream's window. If a stream's flow-control window reaches 0, no further data will be received.\n\nIf manual_window_management is false, this call will have no effect. The connection maintains its flow-control windows such that no back-pressure is applied and data arrives as fast as possible.\n\nPrototype\n\nvoid aws_http_stream_update_window(struct aws_http_stream *stream, size_t increment_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_acquire-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_acquire","text":"aws_websocket_acquire(websocket)\n\nIncrement the websocket's ref-count, preventing it from being destroyed.\n\nReturns\n\nAlways returns the same pointer that is passed in.\n\nPrototype\n\nstruct aws_websocket *aws_websocket_acquire(struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_client_connect-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_client_connect","text":"aws_websocket_client_connect(options)\n\nAsynchronously establish a client websocket connection. The on_connection_setup callback is invoked when the operation has finished creating a connection, or failed.\n\nPrototype\n\nint aws_websocket_client_connect(const struct aws_websocket_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_close-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_close","text":"aws_websocket_close(websocket, free_scarce_resources_immediately)\n\nClose the websocket connection. It is safe to call this, even if the connection is already closed or closing. The websocket will attempt to send a CLOSE frame during normal shutdown. If free_scarce_resources_immediately is true, the connection will be torn down as quickly as possible. This function may be called from any thread.\n\nPrototype\n\nvoid aws_websocket_close(struct aws_websocket *websocket, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_convert_to_midchannel_handler-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_convert_to_midchannel_handler","text":"aws_websocket_convert_to_midchannel_handler(websocket)\n\nConvert the websocket into a mid-channel handler. The websocket will stop being usable via its public API and become just another handler in the channel. The caller will likely install a channel handler to the right. This must not be called in the middle of an incoming frame (between \"frame begin\" and \"frame complete\" callbacks). This MUST be called from the websocket's thread.\n\nIf successful: - Other than aws_websocket_release(), all calls to aws_websocket_x() functions are ignored. - The websocket will no longer invoke any \"incoming frame\" callbacks. - aws_io_messages written by a downstream handler will be wrapped in binary data frames and sent upstream. The data may be split/combined as it is sent along. - aws_io_messages read from upstream handlers will be scanned for binary data frames. The payloads of these frames will be sent downstream. The payloads may be split/combined as they are sent along. - An incoming close frame will automatically result in channel-shutdown. - aws_websocket_release() must still be called or the websocket and its channel will never be cleaned up. - The websocket will still invoke its \"on connection shutdown\" callback when channel shutdown completes.\n\nIf unsuccessful, NULL is returned and the websocket is unchanged.\n\nPrototype\n\nint aws_websocket_convert_to_midchannel_handler(struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_get_channel-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_get_channel","text":"aws_websocket_get_channel(websocket)\n\nReturns the websocket's underlying I/O channel.\n\nPrototype\n\nstruct aws_channel *aws_websocket_get_channel(const struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_increment_read_window","text":"aws_websocket_increment_read_window(websocket, size)\n\nManually increment the read window to keep frames flowing.\n\nIf the websocket was created with manual_window_management set true, then whenever the read window reaches 0 you will stop receiving data. The websocket's initial_window_size determines the starting size of the read window. The read window shrinks as you receive the payload from \"data\" frames (TEXT, BINARY, and CONTINUATION). Use aws_websocket_increment_read_window() to increment the window again and keep frames flowing. Maintain a larger window to keep up high throughput. You only need to worry about the payload from \"data\" frames. The websocket automatically increments the window to account for any other incoming bytes, including other parts of a frame (opcode, payload-length, etc) and the payload of other frame types (PING, PONG, CLOSE).\n\nIf the websocket was created with manual_window_management set false, this function does nothing.\n\nThis function may be called from any thread.\n\nPrototype\n\nvoid aws_websocket_increment_read_window(struct aws_websocket *websocket, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_is_data_frame-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_is_data_frame","text":"aws_websocket_is_data_frame(opcode)\n\nReturn true if opcode is for a data frame, false if opcode if for a control frame.\n\nPrototype\n\nbool aws_websocket_is_data_frame(uint8_t opcode);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_random_handshake_key-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_random_handshake_key","text":"aws_websocket_random_handshake_key(dst)\n\nGenerate value for a Sec-WebSocket-Key header and write it into dst buffer. The buffer should have at least AWS_WEBSOCKET_MAX_HANDSHAKE_KEY_LENGTH space available.\n\nThis value is the base64 encoding of a random 16-byte value. RFC-6455 Section 4.1\n\nPrototype\n\nint aws_websocket_random_handshake_key(struct aws_byte_buf *dst);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_release-Tuple{Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_release","text":"aws_websocket_release(websocket)\n\nDecrement the websocket's ref-count. When the ref-count reaches zero, the connection will shut down, if it hasn't already. Users must release the websocket when they are done with it. The websocket's memory cannot be reclaimed until this is done. Callbacks may continue firing after this is called, with \"shutdown\" being the final callback. This function may be called from any thread.\n\nIt is safe to pass NULL, nothing will happen.\n\nPrototype\n\nvoid aws_websocket_release(struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsHTTP.aws_websocket_send_frame-Tuple{Any, Any}","page":"Home","title":"LibAwsHTTP.aws_websocket_send_frame","text":"aws_websocket_send_frame(websocket, options)\n\nSend a websocket frame. The options struct is copied. A callback will be invoked when the operation completes. This function may be called from any thread.\n\nPrototype\n\nint aws_websocket_send_frame(struct aws_websocket *websocket, const struct aws_websocket_send_frame_options *options);\n\n\n\n\n\n","category":"method"}]
}
